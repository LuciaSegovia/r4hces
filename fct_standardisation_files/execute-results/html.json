{
  "hash": "a9b1cbb9daf4a0283dc6686a036f1954",
  "result": {
    "markdown": "# Food Composition Table & Databases: Standardisation\n\n## Introduction\n\n### Selecting food composition data\n\nWhen selecting the food composition table or database (FCT) that will be used, it is good to reflect on the following questions:\n\n1.  Relevancy for the study/context (e.g., is that FCT/FCBD geographically and culturally close to our survey scope?).\n\n2.  FCT availability & missing values (e.g., are relevant foods and nutrients reported?).\n\n3.  Data quality and reporting (e.g., what are the method of analysis and metadata available?).\n\n\n### Objective\n\nThis document provide, together with the template document, the steps and description for cleaning and standardising FCTs from diverse sources. More details about the cleaned data that can be found in the repository is documented in this folder (documentation).\n\nFor easy navigation and use of this script it is recommended to use Rstudio. In RStudio please click the \"Show Document Outline\" button to the right of the source button, at the top right of this window. This will allow for easier navigation of the script.\n\n## Environment Prep\n\nFirst we need to check what [packages](link-to-packages-explanation) are installed. If you have run this template before in this RStudio project and are sure these packages are already installed, you can comment out (put a hash at the start of) line 20, and skip it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run this to clean the environment\nrm(list = ls())\n\n# Loading libraries\n\nlibrary(readxl) # reading and writing excel files\nlibrary(stringr) # character string handling\nlibrary(dplyr) # cleaning data\nlibrary(here) # file management\n```\n:::\n\n\n\n## Obtaining the raw (FCT) file\n\n### Data License Check\n\nBefore using any dataset, we recommend to check licensing conditions & record the data source, you can use the [README template](link-to-readme-template).\n\n### Data Download\n\nIf the data is publicly available online, usually you only need to run the code below to obtain the raw files. Remember you only need to do it the first time! Then, the data will be stored in the folder of your choice (see below).\n\nFor instance, many raw files can be found provided by the FAO [here](https://www.fao.org/infoods/infoods/tables-and-databases/en/), in various formats. \n\nOnce the link to the data is found, check what file type it is, and paste the direct file link to replace the fill-in value below.\n\n### File names conventions\n\nWe advise to use the ISO code (2 digits) (see [ISO 3166 2-alpha code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes) for further information) of the country or the region of the FCT scope, plus the two last digits of the year of publication to name, both the folder which will contain the data and the scripts related to the FCT. For instance, Western Africa FCT, 2019 will be coded as WA19. This will help with the interoperability, reusability and findability of the data. Also, to streamline the work in the future. That name convention will be used also as the identifier of the FCT. \n\nNote that you need to create the folders to store the FCT. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- \"https://www.fao.org/fileadmin/user_upload/faoweb/2020/WAFCT_2019.xlsx\"\n \n download.file(f, \n             destfile = here::here(\"data\", # data folder\n                                   'WA19', #FCT folder\n                                   #FCT file\n                                   \"WAFCT_2019.xlsx\"),  \n             method=\"wininet\", #use \"curl\" for OS X / Linux, \"wininet\" for Windows\n             mode=\"wb\")\n```\n:::\n\n\nIf using an RStudio project, and you put the .R file and the data file in the same folder as the RStudio project or within a subfolder, files and folders are much easier to navegate as your project/here::here location automatically moves to the main project folder. \n\n#### Using here::here()\n\n##### A brief introduction to here::here()\n\nIf you are using an RStudio project but used a different download method, or already have the file you want to process on your computer, or are using base R we can still use the here::here function, however we will have to find the file first. The best practice is to put the file in the same folder as this script, or in a folder within the project. If this is done, then use `here::here()` to find your current working directory, and then navigate to the file folder. More information about the here package can be found [here](https://here.r-lib.org/).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run this script to see where is your directory\nhere::here()\n```\n:::\n\n\n##### Using here::here()\n\nIn order to navigate there, you have to include each subfolder between the `here::here` location and the file itself (so the 'data' folder, the 'FCT' folder and the FCT file). \n\nFind your file in your project, and then direct here::here to it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This identifies the file and file path, and saves it as a variable\nFCT_file_location <- here::here('data','WA19', \"WAFCT_2019.xlsx\") \n```\n:::\n\n\n\n## Importing the data (loading the data)\n\n#### Using the download code above\n\nFirst, we must find the file on your system that we want to import. If using RStudio: If you used the download method above [Section 1.2](link-to-section) then we will see the same location as specified there to specify the file. Simply copy the contents of the here::here brackets and use it to fill the here::here brackets in the line of code below.\n\n\n### Importing Files\n\nFCT files come in many different forms - the most common being \".xlsx\" files and \".csv\" files. Methods to import both of these file types will be covered - please navigate to the relevant subsection.\n\nDuring import, a identifier for the FCT is created and added to the table. Please replace 'WA19' from the next code chunck with the FCT id., comprised of the countries [ISO 3166 2-alpha code](https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes), and the year the FCT was produced (e.g. for the Western Africa FCT from 2019, the reference would be 'MWA9'). This should be the same as the folder name explained in (section 1.3)\\[link-to-section\\].\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This is an example of the name \nFCT_id <- 'WA19' # Change two first letter for your ISO 2 code & the two digits for the last two digits of the year of publication.\n```\n:::\n\n\n\n#### Importing .xlsx files\n\nFor the excel-type of files, first, you need to check what information is provided and which of the sheet is providing the FC data.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Checking the sheets\n\nreadxl::excel_sheets(FCT_file_location)\n\ndata.df <- readxl::read_excel(FCT_file_location, #The file location, as                            identified in section 2.1\n                              sheet = 5  # Change to the excel sheet where                              the FCT is stored in the excel file\n                              ) %>%  \n  mutate(source_fct = FCT_id)  #Creates the source_fct column and fills with                 a id for this FCT, as filled in in section 2.2. \n```\n:::\n\n\n#### Importing .csv files\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.df <- read.csv2(FCT_file_location, #The file location, as identified in section 2.1\n                     sep = \",\") %>%  # Replace w/ other symbol if needed\n  mutate(source_fct = FCT_id) #Creates the source_fct column and fills with a id for this FCT, as filled in in section 2.2. \n```\n:::\n\n\nOnce imported, it is important to check the data.frame created from the csv, by using `head(data.df)` or clicking on its entry in the Environment panel of RStudio (This second option is not advised with very large files, however, as it can be slow).\n\nIf the data shown by doing this has all its columns combined, with a symbol in-between, then that symbol (e.g. ';') is the separator for that csv. Replace comma in the `sep = \",\"` line from the code block above with the new symbol, and run the entire block again.\n\n\n#### Visually checking the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Checking the dataframe\nhead(data.df) \n```\n:::\n\n\n#### Checking the loaded data\n\n:::{.callout-note} \n## Question\n\nHow many rows & columns have the data?\n\n:::\n\nYou can use the function `dim()` to answer to check the number of rows and column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(data.df) # rows & columns\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Answer\n\n\n\n:::\n\nOther useful functions to evaluate the structure of the data are:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Structure (variable names, class, etc.)\nstr(data.df)\n\n# Checking the last rows and columns\ntail(data.df) \n```\n:::\n\n\n\nFor opening the dataframe in a tab, you can use `View(data.df)`. \n\nNote: if the dataset is very very big, may crash the R session.\n\nAfter checking that the correct FCT file  have loaded the, then proceed. If not, find the correct file and import it instead.\n\n## Cleaning (tidying) and standardising the data\n\n### Formatting FCT into a tabular format \n\n#### Trimming dataframe rows\n\nRunning this will trim down the table to only include the row numbers between x and y - replace x and y with your desired values. If you wanted to include multiple row ranges, that is also possible - use comments to differentiate between different row ranges and individual rows. e.g. if you wanted to include rows a:b, row c, row e, and rows g:x, then the code would be `slice(a:b, c, e, g:x)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.df %>% slice(1:5) %>% knitr::kable()\n```\n:::\n\n\n#### Trimming dataframe columns\n\nIf you only wish to include certain columns/nutrients, then you might wish to remove the unnecessary columns to make the dataframe easier to read and manage. This can be done through 2 methods; either by selecting the names of the columns you want to keep, or by selecting the names of the columns you want to remove.\n\n#### Keep specified columns only\n\nThis method requires creating a list of column names you want to keep - for #example the line below would select the columns 'Energy_kcal', 'Fatg', 'Protein_g', but nothing else. If you wish to trim the columns this way, replace the items in the first line with the column names you want to keep, then run the code block below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Storing the variables you want to keep\ncolumns_to_keep <- c('Scientific name', 'Energy\\r\\n(kJ)')\n\n# Selecting the variables\ndata.df %>% select(columns_to_keep) %>% \n  head(5) %>% \n  knitr::kable()\n```\n:::\n\n\n#### Remove specified columns, keep all others\n\nSometimes it is easier to list the columns you want to remove, rather than the ones you want to keep. The code block below identifies the columns to be removed ('VitB12_mcg' and 'Calcium_mg' in the example), and then removes them. If you wish to trim the columns this way, replace the items in the first line with the column names you want to remove, then run the code block below.\n\nThis works in a similar way to the codeblock in section 3.3.1, however by putting an exclamation mark (!) before the list of columns, it inverts the selection - instead of instructing R to keep only the listed columns (as with the codeblock above), it instructs R to keep all columns but the listed ones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Selecting the variables that you don't want to keep\ncolumns_to_remove <- c('Food name in French', 'Sum of proximate components\\r\\n(g)') \n\ndata.df %>% select(!columns_to_remove) %>% \n  head(5) %>% \n  knitr::kable()\n```\n:::\n\n\n### Creating food groups variable and tidying\n\nSome food composition tables reported food\ngroups that were placed as the first row of each category, however that it is not a data structure that can be used, as we need one column per variable. Hence, the food group names are extracted from the rows, and are allocated as a new attribute of each food (e.g., fish and fishery products to catfish). The food groups are stored in a new column (`food_group`).\n\nThis process requires multiple steps, each covered in their own subsections below: Extracting food group names, Creating the variable, and checking changes in the structure.\n\n#### Extracting food group names\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Creates a list of the food groups using their unique row structure in the table to identify them\n\nfgroup <- data.df %>% \n  filter(is.na(`Food name in English`), !is.na(Code)) %>%\n  pull(Code) %>%\n  stringr::str_split_fixed( '/', n = 2) %>% \n  as_tibble() %>%\n  pull(V1) \n\ngroup.id <-  unique(str_extract(data.df$Code, \"^[:digit:]{2}\\\\_\"))[-1]\n```\n:::\n\n\n# Creating the food_group variable in the FCT\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Removes any rows without a food description entry (the food group name rows, and a row that have already been used for naming)\n\ndata.df <- data.df %>% #Identifies the food group number from the fdc_id, and applies the correct food_group from the fgroup list to the food_group column \n  mutate(food_group = ifelse(grepl(\"01_\", Code), fgroup[1],\n                      ifelse(grepl(\"02_\", Code), fgroup[2],\n                      ifelse(grepl(\"03_\", Code), fgroup[3],\n                      ifelse(grepl(\"04_\", Code), fgroup[4],\n                      ifelse(grepl(\"05_\", Code), fgroup[5],\n                      ifelse(grepl(\"06_\", Code), fgroup[6],\n                      ifelse(grepl(\"07_\", Code), fgroup[7],\n                      ifelse(grepl(\"08_\", Code), fgroup[8],\n                      ifelse(grepl(\"09_\", Code), fgroup[9], \n                      ifelse(grepl(\"10_\", Code), fgroup[10], \n                      ifelse(grepl(\"11_\", Code), fgroup[11], \n                      ifelse(grepl(\"12_\", Code), fgroup[12],\n                      ifelse(grepl(\"13_\", Code), fgroup[13],\n                      ifelse(grepl(\"14_\", Code), fgroup[14],                          'NA')))))))))))))))\n```\n:::\n\n\n\n### Diving combined variables into two (or more) columns\n\nIn some cases, to minimise the number of missing values, two similar food components are combined into one column/ variable. For\nexample, when Beta-carotene and Beta-Carotene Eq. were reported in the same column\nand identified using brackets ([]) around the component values (`CARTEB or [CARTEBEQ]`). However, because we are aiming to have one variable per column, we need to divide the combined variables into two (or more) columns, as such the Beta-carote variable was separated into two independent columns (`CARTEBmg`, `CARTBEQmg`). Note that when we are separating these two food components into the new variable, there are several things that we need to check: we need to check whether they are present in the original FCT, otherwise we may be overwriting values. \n\n1) The variable is not present, then create a new column.\n2) The variable is present: only overwrite if the value is missing in the original column.\n3) Do not remove the brackets from the original variable. As we will add information (metadata) about the quality of the value after removing the brackets. \n\n### Renaming variable names: Food components definition and re-naming\n\nEach FCT has its own variable names, including for similar food components. Some\nFCTs included information related to the FAO/ INFOODS food component identifiers\n[(Tagnames)](https://www.fao.org/infoods/infoods/standards-guidelines/food-component-identifiers-tagnames/en/)\n\nwhile other did not. In order to merge all data from various FCTs we\nneed to harmonise the names of all the variables and particularly the\nfood components of interest. To do so, we evaluated and renamed them\nwith the most appropriate Tagname. Other variables (e.g., food id, food\nname or food description) were renamed to a common variable name, for\ninstance, `fdc_id`, `food_desc`.\n\n\n:::{.callout-note} \n## Question \n\nAre the food component variable names using Tagnames & units, i.e., \\[Variable\\]\\[unit\\] (NAmg)?\n\n:::\n\nIf yes, use that information to rename food components\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Checking current names\nnames(data.df)\n```\n:::\n\n\nIf not, do they provide Tagnames information?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Checking for Tagnames\ndata.df %>% \n  head(5) %>% \n  knitr::kable()\n```\n:::\n\n\nIn this case we can use the Tagname information on the two first rows to rename our variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Automatic renaming \n\nfor( i in 8:62){ #Loops through each column between column 8 and 64\n  first_row <- toString(data.df[1, i]) #Takes the first row for that column and assigns it to a variable\n  second_row <- toString(data.df[2, i]) #Takes the second row for that column and assigns it to a variable\n  split_string <- str_split(first_row, \"\\\\(\") #Splits the first row around \"(\", assigning the two resulting strings to a variable\n  units_int <- gsub(\"\\\\*|\\\\(|\\\\)\", \"\", split_string[[1]][length(split_string[[1]])]) #Separates the units out from the split_string (everything after the last open bracket)\n  colnames(data.df)[i] <- paste0(second_row, units_int) #The column name is replaced with row 1 and the units from row 2\n}\n\n# Checking new names\n\nnames(data.df)\n```\n:::\n\n\nIf information is not provided the manual renaming of the food components would be necessary and hence, the identification of each food component to its Tagname. \n\n##### The identification of food components\n\nInformation on the food components and their description should be\nsought in for FCT.  We advise to use the [(Tagnames)](https://www.fao.org/infoods/infoods/standards-guidelines/food-component-identifiers-tagnames/en/). Some minor changes in the Tagnames are introduced\nto be compliant with R conventions. E.g., removing spaces in variable\nnames, changing symbols to characters (e.g., µg to mcg), or\nstandardising the name formatting from using underscores and/or\nparenthesis to using only underscores. Also, changing dashes (-) to\nunderscores (\\_). Note that within the Tagnames, the dash is used to\ndenote that the method for obtaining that (component) value is unknown.\nThis is important for the quality assessment of the data.\n\nAlso, we also assumed that all the variables labelled as \"standardised\"\nwere combined or recalculated variables.\n\nTable 2. provides a list of all the most relevant food components and their Tagnames. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.csv(here::here(\"data\",           \"fct_variables_standards.csv\")) %>% knitr::kable()\n```\n:::\n\n\nSome other variables can be manually renamed for instance, food code/id, food name, etc.). Change the names in quotes (\"\") to those in your dataset (if needed), remove/ add as needed.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.df <- data.df %>%\ndplyr::rename( \n  fdc_id = \"Code\", # Food id/code \nfood_desc = \"Food name in English\", # Food name/description\nfood_descFR = \"Food name in French\",# Food name/description\nscientific_name = \"Scientific name\", # Scientific name\nEdible_factor_in_FCT = \"Edible portion coefficient 1 (from as purchased to as described)\", # Edible portion\nEdible_factor_in_FCT2 = \"Edible portion coefficient 2 (from as described to as eaten)\", # Edible portion\nnutrient_data_source = \"BiblioID/Source\") # Reference for NVs reported\n\nnames(data.df)[1:5]\n```\n:::\n\n\nAre the variable names = column names? If not, more formatting is needed (back to previous step)\n\n### Standardisation of values\n\nTo perform mathematical operations, characters needed to be converted\ninto numeric operator. This includes three steps: \n\n#### Removing brackets or other special characters.\n\nAs, described above in section, special character (\"[]\", \"()\", \"\\*\")were used to denote \"low quality values\" and/or alternative (determination) methods. We kept record of those values in metadata files for those cases where the numeric\nvalue was extracted and the special character removed. In addition, the variable `comments` was created in a way of keeping that information as metadata for other users.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Creating a dataset w/ the values that were of low quality [] trace or normal\n\nvar_nut <- data.df %>% select(Edible_factor_in_FCT:VITCmg) %>% colnames() #selecting nutrient variable names where we want to check for quality/trace\n\n#dataset w/ metadata info that will be removed from the dataset for use\nmetadata <- data.df %>% mutate_at(var_nut,  ~case_when(\n  str_detect(. , '\\\\[.*?\\\\]') ~ \"low_quality\", #Looking for things in square brackets to mark as low quality\n  str_detect(. , 'tr') ~ \"trace\", #Looking for things marked as \"tr\" and labels them as trace\n  TRUE ~ \"normal_value\")) #Else it marks the entry as a normal value\n```\n:::\n\n\nThe following chunk is related to formatting the FCT section, as here we are creating new varibles to separate those Tagnames and/or similar food components into their individual columns with their Tagnames. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Extracting variables calculated with different (lower quality) method \n#and reported as using [] and removing them from the original variable\n\ndata.df <- data.df %>% \n#Creating calculated values from the lower quality method and removing the original values from the original variable\n  mutate(FATCEg = str_extract(FATg, '(?<=\\\\[).*?(?=\\\\])'),  \n   #e.g. this creates the FIBCg value from the FIBTGg value\n         FIBCg =  str_extract(FIBTGg, '(?<=\\\\[).*?(?=\\\\])'),\n         CARTBmcg = ifelse(is.na(CARTBmcg), str_extract(CARTBEQmcg, '(?<=\\\\[).*?(?=\\\\])'), CARTBmcg), \n         TOCPHAmg = ifelse(is.na(TOCPHAmg),str_extract(VITEmg, '(?<=\\\\[).*?(?=\\\\])'), TOCPHAmg ),\n         NIAmg = ifelse(is.na(NIAmg), str_extract(NIAEQmg, '(?<=\\\\[).*?(?=\\\\])'), NIAmg), \n         FOLSUMmcg = str_extract(FOLmcg, '(?<=\\\\[).*?(?=\\\\])'), \n         PHYTCPPD_PHYTCPPImg = str_extract(PHYTCPPmg, '(?<=\\\\[).*?(?=\\\\])'))\n```\n:::\n\n\n\n#### Changing characters into numeric**\n\nFor instance, values that were reported to be trace (\"tr\") or below the detection limit (\"<LOD\") were converted to zero (0). These changes are also recorded in the `comments` variable as part of the metadata available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#The following f(x) removes [] and changing tr w/ 0\n\nno_brackets_tr <- function(i){\n  case_when(\n    str_detect(i, 'tr|[tr]') ~ \"0\",\n    str_detect(i, '\\\\[.*?\\\\]')  ~ str_extract(i, '(?<=\\\\[).*?(?=\\\\])'),\n    TRUE ~ i)\n}\n\ndata.df <- data.df %>% \n  mutate_at(var_nut, no_brackets_tr) #This applies the above function\n```\n:::\n\n\n\n#### Extracting information\n\nSome food component information, for instance alcohol content, could be reported within the food description instead of in a independent variable. Hence that information needs to be extracted and a new variable generated. \n\n#### Converting into numeric\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Converting to numeric\n\nwafct <- wafct %>% mutate_at(vars(`Edible_factor_in_FCT`:`PHYTCPPD_PHYTCPPImg`), as.numeric) #Converts certain columns (the data columns) to numeric\n```\n:::\n\n\n\n### Standardising unit of measurement <br>\n\nTo standardise and merge the different FCTs, food components need to be\nreported in the same units. For example, some nutrients needed to be\nconvert from mg/100g to g/100g, or from percentage (100%) to a fraction (1). For all the unit conversion we followed the FAO/INFOODS Guidelines for\nConverting Units, Denominators and Expression (FAO/INFOODS, 2012b), and\nthe suggested standard reporting units.\n\nEg. Converting alcohol from weight in volume (w/v) to weight in mass (w/m) (Eq.1a) or percentage of alcohol (v/v) into weight mass (Eq.1b) (See INFOODS Guidelines - page 12). \n\n**Eq.1a** ALC (g/100mL) (w/v) / density (g/mL) = ALC (g/100 EP)\n\n**Eq.1b** ALC (%) (v/v) * 0.789 (g/mL) / density (g/mL) = ALC (g/100 EP) \n\nEg. amino acids (AA) reported per g in 100g of PROT to mg in 100g of EP:\n\n**Eq.2.1** AA mg/100g EP = AA mg/g prot \\* prot g/100g EP /100\n\n**Eq.2.2** AA mg/100g EP = AA g/ 100g prot \\* prot g/100g EP /100 \\*\n1000/100\n\n**Eq.2.3** AA mg/100g EP = AA g/100g prot \\* prot g/100g EP \\*10\n\n\\\\Eq.3: Edible portion = Edible portion (%)/100\n\n\n##### Data quality and reporting (e.g., method of analysis, good metadata)\n\n\nGeneral quality checks are: the level of detail in the food description, the methods used for nutrient values compilation, and the documentation and degree of detail.\n\nOther quality checks that can be performed are: calculating sum of proximate and re-calculating the values of: Carbohydrates available by difference, energy, etc. These is covered in the visualisation and QC section. \n\n### Saving the output\n\nWe are saving the standardised FCT into the data folder, for use in the future.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Data Output \n\nwrite.csv(data.df, file = here::here(\"data\", paste0(FCT_id, \"_FCT_FAO_Tags.csv\")), \n          row.names = FALSE) #Saves the newly-created data table to the Output folder\n\n#Run this to clean the environment\nrm(list = ls())\n```\n:::\n\n\n## Further readings\n\n1. Charrondiere, U.R., Stadlmayr, B., Grande, F., Vincent, A., Oseredczuk, M., Sivakumaran, S., Puwastien, P., Judprasong, K., Haytowitz, D., Gnagnarella, P. 2023. FAO/INFOODS Evaluation framework to assess the quality of published food composition tables and databases - User guide. Rome, FAO. https://doi.org/10.4060/cc5371en",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}